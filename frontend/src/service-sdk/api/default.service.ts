/**
 * Propio API
 * Microservice for partner managment
 *
 * OpenAPI spec version: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 *//* tslint:disable:no-unused-variable member-ordering */

import { Inject, Injectable, Optional }                      from '@angular/core';
import { HttpClient, HttpHeaders, HttpParams,
         HttpResponse, HttpEvent }                           from '@angular/common/http';
import { CustomHttpUrlEncodingCodec }                        from '../encoder';

import { Observable }                                        from 'rxjs';

import { BankAccountMapping } from '../model/bankAccountMapping';
import { BankAccountMappingResult } from '../model/bankAccountMappingResult';
import { BankLinkConnectionRequest } from '../model/bankLinkConnectionRequest';
import { Client } from '../model/client';
import { LedgerAccount } from '../model/ledgerAccount';
import { Organization } from '../model/organization';
import { Partner } from '../model/partner';
import { PartnerOnboardingRequest } from '../model/partnerOnboardingRequest';
import { RedirectionUrl } from '../model/redirectionUrl';
import { SendMessageRequest } from '../model/sendMessageRequest';
import { ShareClientParams } from '../model/shareClientParams';
import { Transaction } from '../model/transaction';
import { TransactionCategorizationRequest } from '../model/transactionCategorizationRequest';
import { User } from '../model/user';

import { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';
import { Configuration }                                     from '../configuration';


@Injectable()
export class DefaultService {

    protected basePath = 'http://localhost';
    public defaultHeaders = new HttpHeaders();
    public configuration = new Configuration();

    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string, @Optional() configuration: Configuration) {
        if (basePath) {
            this.basePath = basePath;
        }
        if (configuration) {
            this.configuration = configuration;
            this.basePath = basePath || configuration.basePath || this.basePath;
        }
    }

    /**
     * @param consumes string[] mime-types
     * @return true: consumes contains 'multipart/form-data', false: otherwise
     */
    private canConsumeForm(consumes: string[]): boolean {
        const form = 'multipart/form-data';
        for (const consume of consumes) {
            if (form === consume) {
                return true;
            }
        }
        return false;
    }


    /**
     * Categorize a transaction on a ledger
     * Categorizes the transaction in the ledger and updates its data in the database.  This operation is meant to be called in a background task or queue.
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public categorizeTransactionOnLedger(body: TransactionCategorizationRequest, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public categorizeTransactionOnLedger(body: TransactionCategorizationRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public categorizeTransactionOnLedger(body: TransactionCategorizationRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public categorizeTransactionOnLedger(body: TransactionCategorizationRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling categorizeTransactionOnLedger.');
        }

        let headers = this.defaultHeaders;

        // authentication (BearerAuth) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<any>('put',`${this.basePath}/api/categorize`,
            {
                body: body,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Create a new client
     * Creates a client with the given data for a given partner and a given organization.
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public createClient(body: Client, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public createClient(body: Client, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public createClient(body: Client, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public createClient(body: Client, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling createClient.');
        }

        let headers = this.defaultHeaders;

        // authentication (BearerAuth) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<any>('post',`${this.basePath}/api/clients`,
            {
                body: body,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param partner_id 
     * @param organization_id 
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public createTransactionForOrganization(partner_id: number, organization_id: number, body?: Transaction, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public createTransactionForOrganization(partner_id: number, organization_id: number, body?: Transaction, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public createTransactionForOrganization(partner_id: number, organization_id: number, body?: Transaction, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public createTransactionForOrganization(partner_id: number, organization_id: number, body?: Transaction, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (partner_id === null || partner_id === undefined) {
            throw new Error('Required parameter partner_id was null or undefined when calling createTransactionForOrganization.');
        }

        if (organization_id === null || organization_id === undefined) {
            throw new Error('Required parameter organization_id was null or undefined when calling createTransactionForOrganization.');
        }


        let headers = this.defaultHeaders;

        // authentication (BearerAuth) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<any>('post',`${this.basePath}/api/partners/${encodeURIComponent(String(partner_id))}/organizations/${encodeURIComponent(String(organization_id))}/transactions`,
            {
                body: body,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Edit client data
     * Update client data
     * @param body 
     * @param client_id Client ID
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public editClient(body: Client, client_id: number, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public editClient(body: Client, client_id: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public editClient(body: Client, client_id: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public editClient(body: Client, client_id: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling editClient.');
        }

        if (client_id === null || client_id === undefined) {
            throw new Error('Required parameter client_id was null or undefined when calling editClient.');
        }

        let headers = this.defaultHeaders;

        // authentication (BearerAuth) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<any>('put',`${this.basePath}/api/clients/${encodeURIComponent(String(client_id))}`,
            {
                body: body,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Edit organization data
     * update organization data
     * @param body 
     * @param organization_id 
     * @param partner_id 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public editOrganization(body: Organization, organization_id: number, partner_id: number, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public editOrganization(body: Organization, organization_id: number, partner_id: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public editOrganization(body: Organization, organization_id: number, partner_id: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public editOrganization(body: Organization, organization_id: number, partner_id: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling editOrganization.');
        }

        if (organization_id === null || organization_id === undefined) {
            throw new Error('Required parameter organization_id was null or undefined when calling editOrganization.');
        }

        if (partner_id === null || partner_id === undefined) {
            throw new Error('Required parameter partner_id was null or undefined when calling editOrganization.');
        }

        let headers = this.defaultHeaders;

        // authentication (BearerAuth) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<any>('put',`${this.basePath}/api/partners/${encodeURIComponent(String(partner_id))}/organizations/${encodeURIComponent(String(organization_id))}`,
            {
                body: body,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param client_id 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getAccountingMappings(client_id: number, observe?: 'body', reportProgress?: boolean): Observable<BankAccountMappingResult>;
    public getAccountingMappings(client_id: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<BankAccountMappingResult>>;
    public getAccountingMappings(client_id: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<BankAccountMappingResult>>;
    public getAccountingMappings(client_id: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (client_id === null || client_id === undefined) {
            throw new Error('Required parameter client_id was null or undefined when calling getAccountingMappings.');
        }

        let headers = this.defaultHeaders;

        // authentication (BearerAuth) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<BankAccountMappingResult>('get',`${this.basePath}/api/clients/${encodeURIComponent(String(client_id))}/mappings`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get a list of clients
     * Get a list of clients associated with the logged in partner. Use provided JWT token to look for clients of the logged partner 
     * @param offset Offset for query
     * @param limit How many clients do you want in this request
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getClients(offset: number, limit: number, observe?: 'body', reportProgress?: boolean): Observable<Array<Client>>;
    public getClients(offset: number, limit: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<Client>>>;
    public getClients(offset: number, limit: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<Client>>>;
    public getClients(offset: number, limit: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (offset === null || offset === undefined) {
            throw new Error('Required parameter offset was null or undefined when calling getClients.');
        }

        if (limit === null || limit === undefined) {
            throw new Error('Required parameter limit was null or undefined when calling getClients.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (offset !== undefined && offset !== null) {
            queryParameters = queryParameters.set('offset', <any>offset);
        }
        if (limit !== undefined && limit !== null) {
            queryParameters = queryParameters.set('limit', <any>limit);
        }

        let headers = this.defaultHeaders;

        // authentication (BearerAuth) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<Array<Client>>('get',`${this.basePath}/api/clients`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param partner_id 
     * @param organization_id 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getFinancialInstitutionConnectionUrl(partner_id: number, organization_id: number, observe?: 'body', reportProgress?: boolean): Observable<BankLinkConnectionRequest>;
    public getFinancialInstitutionConnectionUrl(partner_id: number, organization_id: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<BankLinkConnectionRequest>>;
    public getFinancialInstitutionConnectionUrl(partner_id: number, organization_id: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<BankLinkConnectionRequest>>;
    public getFinancialInstitutionConnectionUrl(partner_id: number, organization_id: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (partner_id === null || partner_id === undefined) {
            throw new Error('Required parameter partner_id was null or undefined when calling getFinancialInstitutionConnectionUrl.');
        }

        if (organization_id === null || organization_id === undefined) {
            throw new Error('Required parameter organization_id was null or undefined when calling getFinancialInstitutionConnectionUrl.');
        }

        let headers = this.defaultHeaders;

        // authentication (BearerAuth) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<BankLinkConnectionRequest>('get',`${this.basePath}/api/partners/${encodeURIComponent(String(partner_id))}/organizations/${encodeURIComponent(String(organization_id))}/financial_accounts/connection_url`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * A list of accounts.
     * 
     * @param partner_id 
     * @param organization_id 
     * @param ledger_id ID of the ledger to connect to
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getLedgerChartOfAccounts(partner_id: number, organization_id: number, ledger_id: number, observe?: 'body', reportProgress?: boolean): Observable<Array<LedgerAccount>>;
    public getLedgerChartOfAccounts(partner_id: number, organization_id: number, ledger_id: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<LedgerAccount>>>;
    public getLedgerChartOfAccounts(partner_id: number, organization_id: number, ledger_id: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<LedgerAccount>>>;
    public getLedgerChartOfAccounts(partner_id: number, organization_id: number, ledger_id: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (partner_id === null || partner_id === undefined) {
            throw new Error('Required parameter partner_id was null or undefined when calling getLedgerChartOfAccounts.');
        }

        if (organization_id === null || organization_id === undefined) {
            throw new Error('Required parameter organization_id was null or undefined when calling getLedgerChartOfAccounts.');
        }

        if (ledger_id === null || ledger_id === undefined) {
            throw new Error('Required parameter ledger_id was null or undefined when calling getLedgerChartOfAccounts.');
        }

        let headers = this.defaultHeaders;

        // authentication (BearerAuth) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<Array<LedgerAccount>>('get',`${this.basePath}/api/partners/${encodeURIComponent(String(partner_id))}/organizations/${encodeURIComponent(String(organization_id))}/ledgers/${encodeURIComponent(String(ledger_id))}/accounts`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param partner_id 
     * @param organization_id 
     * @param ledger_id ID of the ledger to connect to
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getLedgerConnectionUrl(partner_id: number, organization_id: number, ledger_id: number, observe?: 'body', reportProgress?: boolean): Observable<RedirectionUrl>;
    public getLedgerConnectionUrl(partner_id: number, organization_id: number, ledger_id: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<RedirectionUrl>>;
    public getLedgerConnectionUrl(partner_id: number, organization_id: number, ledger_id: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<RedirectionUrl>>;
    public getLedgerConnectionUrl(partner_id: number, organization_id: number, ledger_id: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (partner_id === null || partner_id === undefined) {
            throw new Error('Required parameter partner_id was null or undefined when calling getLedgerConnectionUrl.');
        }

        if (organization_id === null || organization_id === undefined) {
            throw new Error('Required parameter organization_id was null or undefined when calling getLedgerConnectionUrl.');
        }

        if (ledger_id === null || ledger_id === undefined) {
            throw new Error('Required parameter ledger_id was null or undefined when calling getLedgerConnectionUrl.');
        }

        let headers = this.defaultHeaders;

        // authentication (BearerAuth) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<RedirectionUrl>('get',`${this.basePath}/api/partners/${encodeURIComponent(String(partner_id))}/organizations/${encodeURIComponent(String(organization_id))}/ledgers/${encodeURIComponent(String(ledger_id))}/connection_url`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param partner_id 
     * @param organization_id 
     * @param ledger_id 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getLedgerDetails(partner_id: number, organization_id: number, ledger_id: number, observe?: 'body', reportProgress?: boolean): Observable<RedirectionUrl>;
    public getLedgerDetails(partner_id: number, organization_id: number, ledger_id: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<RedirectionUrl>>;
    public getLedgerDetails(partner_id: number, organization_id: number, ledger_id: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<RedirectionUrl>>;
    public getLedgerDetails(partner_id: number, organization_id: number, ledger_id: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (partner_id === null || partner_id === undefined) {
            throw new Error('Required parameter partner_id was null or undefined when calling getLedgerDetails.');
        }

        if (organization_id === null || organization_id === undefined) {
            throw new Error('Required parameter organization_id was null or undefined when calling getLedgerDetails.');
        }

        if (ledger_id === null || ledger_id === undefined) {
            throw new Error('Required parameter ledger_id was null or undefined when calling getLedgerDetails.');
        }

        let headers = this.defaultHeaders;

        // authentication (BearerAuth) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<RedirectionUrl>('get',`${this.basePath}/api/partners/${encodeURIComponent(String(partner_id))}/organizations/${encodeURIComponent(String(organization_id))}/ledgers/${encodeURIComponent(String(ledger_id))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * GetOrganizationBasedClients
     * get all clients from a organization
     * @param organization_id 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getOrganizationClients(organization_id: number, observe?: 'body', reportProgress?: boolean): Observable<Array<Client>>;
    public getOrganizationClients(organization_id: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<Client>>>;
    public getOrganizationClients(organization_id: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<Client>>>;
    public getOrganizationClients(organization_id: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (organization_id === null || organization_id === undefined) {
            throw new Error('Required parameter organization_id was null or undefined when calling getOrganizationClients.');
        }

        let headers = this.defaultHeaders;

        // authentication (BearerAuth) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<Array<Client>>('get',`${this.basePath}/api/clients/organizations/${encodeURIComponent(String(organization_id))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param partner_id 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getOrganizationsForPartner(partner_id: number, observe?: 'body', reportProgress?: boolean): Observable<Array<Organization>>;
    public getOrganizationsForPartner(partner_id: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<Organization>>>;
    public getOrganizationsForPartner(partner_id: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<Organization>>>;
    public getOrganizationsForPartner(partner_id: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (partner_id === null || partner_id === undefined) {
            throw new Error('Required parameter partner_id was null or undefined when calling getOrganizationsForPartner.');
        }

        let headers = this.defaultHeaders;

        // authentication (BearerAuth) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<Array<Organization>>('get',`${this.basePath}/api/partners/${encodeURIComponent(String(partner_id))}/organizations`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getPartnersFromEmails(body: Array<string>, observe?: 'body', reportProgress?: boolean): Observable<Array<Partner>>;
    public getPartnersFromEmails(body: Array<string>, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<Partner>>>;
    public getPartnersFromEmails(body: Array<string>, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<Partner>>>;
    public getPartnersFromEmails(body: Array<string>, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling getPartnersFromEmails.');
        }

        let headers = this.defaultHeaders;

        // authentication (BearerAuth) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<Array<Partner>>('post',`${this.basePath}/api/partners/fromEmails`,
            {
                body: body,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param transaction_id 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getTransactionId(transaction_id: number, observe?: 'body', reportProgress?: boolean): Observable<Transaction>;
    public getTransactionId(transaction_id: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Transaction>>;
    public getTransactionId(transaction_id: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Transaction>>;
    public getTransactionId(transaction_id: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (transaction_id === null || transaction_id === undefined) {
            throw new Error('Required parameter transaction_id was null or undefined when calling getTransactionId.');
        }

        let headers = this.defaultHeaders;

        // authentication (BearerAuth) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<Transaction>('get',`${this.basePath}/api/transactions/${encodeURIComponent(String(transaction_id))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param client_id 
     * @param merchant_query Filter by merchant
     * @param categorization_status 
     * @param date_start 
     * @param date_end 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getTransactionsForClient(client_id: number, merchant_query?: string, categorization_status?: string, date_start?: string, date_end?: string, observe?: 'body', reportProgress?: boolean): Observable<Array<Transaction>>;
    public getTransactionsForClient(client_id: number, merchant_query?: string, categorization_status?: string, date_start?: string, date_end?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<Transaction>>>;
    public getTransactionsForClient(client_id: number, merchant_query?: string, categorization_status?: string, date_start?: string, date_end?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<Transaction>>>;
    public getTransactionsForClient(client_id: number, merchant_query?: string, categorization_status?: string, date_start?: string, date_end?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (client_id === null || client_id === undefined) {
            throw new Error('Required parameter client_id was null or undefined when calling getTransactionsForClient.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (merchant_query !== undefined && merchant_query !== null) {
            queryParameters = queryParameters.set('merchant_query', <any>merchant_query);
        }
        if (categorization_status !== undefined && categorization_status !== null) {
            queryParameters = queryParameters.set('categorization_status', <any>categorization_status);
        }
        if (date_start !== undefined && date_start !== null) {
            queryParameters = queryParameters.set('date_start', <any>date_start);
        }
        if (date_end !== undefined && date_end !== null) {
            queryParameters = queryParameters.set('date_end', <any>date_end);
        }

        let headers = this.defaultHeaders;

        // authentication (BearerAuth) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<Array<Transaction>>('get',`${this.basePath}/api/clients/${encodeURIComponent(String(client_id))}/transactions`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param auth0_id 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getUserByAuth0Id(auth0_id: string, observe?: 'body', reportProgress?: boolean): Observable<User>;
    public getUserByAuth0Id(auth0_id: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<User>>;
    public getUserByAuth0Id(auth0_id: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<User>>;
    public getUserByAuth0Id(auth0_id: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (auth0_id === null || auth0_id === undefined) {
            throw new Error('Required parameter auth0_id was null or undefined when calling getUserByAuth0Id.');
        }

        let headers = this.defaultHeaders;

        // authentication (BearerAuth) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<User>('get',`${this.basePath}/api/users/${encodeURIComponent(String(auth0_id))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Create a user with a given auth0 id
     * 
     * @param body 
     * @param auth0_id 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public onboardUser(body: PartnerOnboardingRequest, auth0_id: string, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public onboardUser(body: PartnerOnboardingRequest, auth0_id: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public onboardUser(body: PartnerOnboardingRequest, auth0_id: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public onboardUser(body: PartnerOnboardingRequest, auth0_id: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling onboardUser.');
        }

        if (auth0_id === null || auth0_id === undefined) {
            throw new Error('Required parameter auth0_id was null or undefined when calling onboardUser.');
        }

        let headers = this.defaultHeaders;

        // authentication (BearerAuth) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<any>('post',`${this.basePath}/api/partners/${encodeURIComponent(String(auth0_id))}/onboard`,
            {
                body: body,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Import the Chart of Accounts from the Ledger
     * 
     * @param partner_id 
     * @param organization_id 
     * @param ledger_id ID of the ledger to connect to
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public refreshChartOfAccounts(partner_id: number, organization_id: number, ledger_id: number, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public refreshChartOfAccounts(partner_id: number, organization_id: number, ledger_id: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public refreshChartOfAccounts(partner_id: number, organization_id: number, ledger_id: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public refreshChartOfAccounts(partner_id: number, organization_id: number, ledger_id: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (partner_id === null || partner_id === undefined) {
            throw new Error('Required parameter partner_id was null or undefined when calling refreshChartOfAccounts.');
        }

        if (organization_id === null || organization_id === undefined) {
            throw new Error('Required parameter organization_id was null or undefined when calling refreshChartOfAccounts.');
        }

        if (ledger_id === null || ledger_id === undefined) {
            throw new Error('Required parameter ledger_id was null or undefined when calling refreshChartOfAccounts.');
        }

        let headers = this.defaultHeaders;

        // authentication (BearerAuth) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<any>('post',`${this.basePath}/api/partners/${encodeURIComponent(String(partner_id))}/organizations/${encodeURIComponent(String(organization_id))}/ledgers/${encodeURIComponent(String(ledger_id))}/accounts`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param body 
     * @param client_id 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public saveMappings(body: Array<BankAccountMapping>, client_id: number, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public saveMappings(body: Array<BankAccountMapping>, client_id: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public saveMappings(body: Array<BankAccountMapping>, client_id: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public saveMappings(body: Array<BankAccountMapping>, client_id: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling saveMappings.');
        }

        if (client_id === null || client_id === undefined) {
            throw new Error('Required parameter client_id was null or undefined when calling saveMappings.');
        }

        let headers = this.defaultHeaders;

        // authentication (BearerAuth) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<any>('post',`${this.basePath}/api/clients/${encodeURIComponent(String(client_id))}/mappings`,
            {
                body: body,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Create a user with a given auth0 id
     * 
     * @param body 
     * @param auth0_id 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public saveUser(body: User, auth0_id: string, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public saveUser(body: User, auth0_id: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public saveUser(body: User, auth0_id: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public saveUser(body: User, auth0_id: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling saveUser.');
        }

        if (auth0_id === null || auth0_id === undefined) {
            throw new Error('Required parameter auth0_id was null or undefined when calling saveUser.');
        }

        let headers = this.defaultHeaders;

        // authentication (BearerAuth) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<any>('post',`${this.basePath}/api/users/${encodeURIComponent(String(auth0_id))}`,
            {
                body: body,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Send a message
     * 
     * @param channel_id 
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public sendMessage(channel_id: number, body?: SendMessageRequest, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public sendMessage(channel_id: number, body?: SendMessageRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public sendMessage(channel_id: number, body?: SendMessageRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public sendMessage(channel_id: number, body?: SendMessageRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (channel_id === null || channel_id === undefined) {
            throw new Error('Required parameter channel_id was null or undefined when calling sendMessage.');
        }


        let headers = this.defaultHeaders;

        // authentication (BearerAuth) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<any>('post',`${this.basePath}/api/messages/channel/${encodeURIComponent(String(channel_id))}/send`,
            {
                body: body,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Share multiple clients with multiple partners
     * 
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public shareClientsforPartners(body: ShareClientParams, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public shareClientsforPartners(body: ShareClientParams, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public shareClientsforPartners(body: ShareClientParams, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public shareClientsforPartners(body: ShareClientParams, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling shareClientsforPartners.');
        }

        let headers = this.defaultHeaders;

        // authentication (BearerAuth) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<any>('post',`${this.basePath}/api/share`,
            {
                body: body,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param transaction_id 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public suggestCategoryForTransaction(transaction_id: number, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public suggestCategoryForTransaction(transaction_id: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public suggestCategoryForTransaction(transaction_id: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public suggestCategoryForTransaction(transaction_id: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (transaction_id === null || transaction_id === undefined) {
            throw new Error('Required parameter transaction_id was null or undefined when calling suggestCategoryForTransaction.');
        }

        let headers = this.defaultHeaders;

        // authentication (BearerAuth) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<any>('post',`${this.basePath}/api/transactions/${encodeURIComponent(String(transaction_id))}/suggest`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Update the category of a transaction.
     * 
     * @param body 
     * @param transaction_id 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public updateTransaction(body: Transaction, transaction_id: number, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public updateTransaction(body: Transaction, transaction_id: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public updateTransaction(body: Transaction, transaction_id: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public updateTransaction(body: Transaction, transaction_id: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling updateTransaction.');
        }

        if (transaction_id === null || transaction_id === undefined) {
            throw new Error('Required parameter transaction_id was null or undefined when calling updateTransaction.');
        }

        let headers = this.defaultHeaders;

        // authentication (BearerAuth) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<any>('post',`${this.basePath}/api/transactions/${encodeURIComponent(String(transaction_id))}`,
            {
                body: body,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Update multiple transactions at once.
     * 
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public updateTransactions(body: Array<Transaction>, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public updateTransactions(body: Array<Transaction>, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public updateTransactions(body: Array<Transaction>, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public updateTransactions(body: Array<Transaction>, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling updateTransactions.');
        }

        let headers = this.defaultHeaders;

        // authentication (BearerAuth) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<any>('post',`${this.basePath}/api/transactions`,
            {
                body: body,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

}

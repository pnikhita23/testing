import {
  NotFoundException,
  ForbiddenException,
  BadRequestException,
  GenericException,
} from "../dependencies/exceptions";

// ////////////////////////////////////////////////////////////////////////////
//
// Injectable dependencies
//
// ////////////////////////////////////////////////////////////////////////////
import { IQueueProvider } from "../dependencies/queues/queue.interface";
import { IDatabase } from "../dependencies/database.interface";
import { IClock } from "../dependencies/clock.interface";
import { dateutils } from "../dependencies/dateutil";
import { logger } from "../dependencies/logger";
import { PropioAiCategorizationMicroservice } from "../dependencies/propio-ai/propio-ai";

// Mailchimp Marketing config
const MailchimpMarketingClient = require("@mailchimp/mailchimp_marketing");

MailchimpMarketingClient.setConfig({
  apiKey: process.env.MAILCHIMP_API_KEY,
  server: process.env.MAILCHIMP_SERVER_PREFIX,
});

import { DefaultApiInterface } from "./DefaultApi.interfaces";
import {
  requireUserId,
  requireGlobalAdmin,
  isUserGlobalAdmin,
  isUserProjectAdmin,
  isUserInOrganization,
} from "./AccessUtilities";

// ////////////////////////////////////////////////////////////////////////////
//
// Controllers. Most business logic should happen in the controllers.
//
// ////////////////////////////////////////////////////////////////////////////
import { HubSpotService } from "../controllers/hubspot";
import { PartnerController } from "../controllers/partners";

// ////////////////////////////////////////////////////////////////////////////
//
// Backend specific models. These are models used to interact in the DB and
// pass data around, even back to the API callers. Thats's wrong, for returning
// data we need to use the SDK models.
//
// ////////////////////////////////////////////////////////////////////////////

// ////////////////////////////////////////////////////////////////////////////
//
// Models generated by the API specification. These models should be used to
// read requests and return reponses.
//
// ////////////////////////////////////////////////////////////////////////////
import {
  BankAccountMapping,
  BankAccountMappingResult,
  BankLinkConnectionRequest,
  BankAccount,
  Client,
  LedgerAccount,
  Organization,
  PartnerOnboardingRequest,
  RedirectionUrl,
  SendMessageRequest,
  Transaction,
  TransactionCategorizationRequest,
  User,
  ShareClientParams,
  Partner,
} from "../models/sdk/models";

import { APIGatewayProxyEventV2 } from "aws-lambda";
import { UserController } from "../controllers/users";
import { PropioBankingMicroservice } from "../dependencies/propio-banking/propio-banking";
import { ClientController } from "../controllers/clients";
import { PropioLedgersMicroservice } from "../dependencies/propio-ledgers/propio-ledgers";
import { TransactionsController } from "../controllers/transactions";
import { TransactionCategorizationMessage } from "../dependencies/propio-ledgers/transaction-categorization-message";
import { ConenctedLedger } from "../models/backend/models";
import { OrganizationsController } from "../controllers/organizations";
import { AccountingController } from "../controllers/accounting";

require("dotenv").config();

// ////////////////////////////////////////////////////////////////////////////
//
// Utility functions
//
// ////////////////////////////////////////////////////////////////////////////
// eslint-disable-next-line @typescript-eslint/no-unused-vars
const requirePathParameter = (
  lambdaEvent,
  parameterName: string,
  errorMessage = null
) => {
  if (lambdaEvent.pathParameters == undefined) {
    throw Error(
      errorMessage == null ? `Missing parameter ${parameterName}` : errorMessage
    );
  }

  if (!lambdaEvent.pathParameters[parameterName]) {
    throw Error(
      errorMessage == null ? `Missing parameter ${parameterName}` : errorMessage
    );
  }

  return lambdaEvent.pathParameters[parameterName];
};

/**
 * Gets a user's license details by their email and updates Hubspot accordingly
 * if it still says their license is valid but it is past the expiry date. Additionally,
 * updates the user_license table as a backup cache. If HubSpot cannot be accessed,
 * pulls user information from the user_license table if applicable.
 */
async function getLicenseForUser(
  email: string,
  devmatch_user_id: string,
  db: any,
  systemClock: IClock
): Promise<any> {
  const hubspot = new HubSpotService();

  try {
    const hubspotProperties = await hubspot.getContactPropertiesByEmail(email, [
      "devmatch_valid_license",
      "devmatch_valid_license_expiry_date",
    ]);

    const licenseResult: any = {
      devmatch_valid_license_expiry_date:
        hubspotProperties.devmatch_valid_license_expiry_date,
    };

    /*
    the license is considered valid if HubSpot says it is and
    the expiry date is null or not yet past. Otherwise, the license is invalid.
    */
    const licenseExpiryDate = new Date(
      hubspotProperties.devmatch_valid_license_expiry_date
    );
    const expiryDateIsNull = isNaN(licenseExpiryDate.valueOf());

    if (hubspotProperties.devmatch_valid_license && expiryDateIsNull) {
      licenseResult.devmatch_valid_license = true;
    } else {
      licenseResult.devmatch_valid_license =
        systemClock.getCurrentTime() < licenseExpiryDate;
    }

    /*
    if the license is no longer valid but hubspot still says it is, update hubspot.
    we do not update if hubspot says the license is invalid but expiry date has not yet passed
    as this could be triggered by a subscription manually being ended early, etc.
    */
    const hubspotHasDiscrepancy =
      !licenseResult.devmatch_valid_license &&
      hubspotProperties.devmatch_valid_license;

    if (hubspotHasDiscrepancy) {
      const updates = {
        devmatch_valid_license: "false",
      };
      await hubspot.updateContactProperties(
        hubspotProperties.hs_object_id,
        updates
      );
    }

    // update the backup license table in the database; first, check for existing records
    const { rows } = await db.execute(
      `SELECT * FROM user_license WHERE user_id = ?`,
      [devmatch_user_id]
    );

    // then, format the expiry date to be stored in the db, explicitly allowing null values
    let formattedLicenseExpiryDate;
    try {
      formattedLicenseExpiryDate =
        dateutils.datetimeToDatabase(licenseExpiryDate);
    } catch (e) {
      formattedLicenseExpiryDate = null;
    }

    if (!rows[0]) {
      // this user's license data is not yet in the table
      const dateModified = dateutils.datetimeToDatabase(
        systemClock.getCurrentTime()
      );

      await db.execute(
        `INSERT INTO user_license (user_id, hubspot_contact_id, valid_license, license_expiry_date, date_modified)
         VALUES(?, ?, ?, ?, ?)`,
        [
          devmatch_user_id,
          hubspotProperties.hs_object_id,
          licenseResult.devmatch_valid_license,
          formattedLicenseExpiryDate,
          dateModified,
        ]
      );
    } else {
      // the user exists. does their data match?
      const tableProperties = rows[0];
      let updateFields = "";
      const updateValues: any[] = [];

      if (
        tableProperties.hubspot_contact_id !== hubspotProperties.hs_object_id
      ) {
        updateFields += `hubspot_contact_id = ?,`;
        updateValues.push(hubspotProperties.hs_object_id);
      }

      if (
        Boolean(tableProperties.valid_license) !==
        licenseResult.devmatch_valid_license
      ) {
        updateFields += `valid_license = ?,`;
        updateValues.push(licenseResult.devmatch_valid_license);
      }

      if (tableProperties.license_expiry_date !== formattedLicenseExpiryDate) {
        updateFields += `license_expiry_date = ?,`;
        updateValues.push(formattedLicenseExpiryDate);
      }

      if (updateValues.length > 0) {
        updateFields += `date_modified = ?`;
        updateValues.push(
          dateutils.datetimeToDatabase(systemClock.getCurrentTime())
        );

        await db.execute(
          `UPDATE user_license SET ${updateFields} WHERE user_id = ?`,
          [...updateValues, devmatch_user_id]
        );
      }
    }

    return licenseResult;
  } catch (e) {
    logger.error(e);

    // try to get the data from the db cache instead
    const { rows } = await db.execute(
      `SELECT * FROM user_license WHERE user_id = ?`,
      [devmatch_user_id]
    );

    if (!rows[0]) {
      return { devmatch_valid_license: false };
    }

    return {
      devmatch_valid_license: rows[0].valid_license === 1,
      devmatch_valid_license_expiry_date: rows[0].license_expiry_date,
      hs_object_id: rows[0].hubspot_contact_id,
    };
  }
}

// eslint-disable-next-line @typescript-eslint/no-unused-vars
function getRequestBody(event) {
  // Read the body from the request
  let body: any = {};
  if (event.body != undefined) {
    body = JSON.parse(JSON.stringify(event.body));
  }
  return body;
}

// ////////////////////////////////////////////////////////////////////////////
//
// API
//
// ////////////////////////////////////////////////////////////////////////////
export class RestApiImplementation implements DefaultApiInterface {
  private db: IDatabase;
  private queue: IQueueProvider;
  private systemClock: IClock;
  private event;

  public constructor(
    db: IDatabase,
    queue: IQueueProvider,
    systemClock: IClock,
    event: APIGatewayProxyEventV2
  ) {
    this.db = db;
    this.queue = queue;
    this.event = event;
    this.systemClock = systemClock;
  }

  /**
   * Triggers a refresh to the chart of accounts for a client.
   *
   * The real work is done in the background in a Cloud Task in the classic Propio Ledger Firebase project
   *
   * @param partnerId The partner ID
   * @param organizationId The organization ID of the Client
   * @param ledgerId [NOT USED] The ledger ID
   *
   * @throws NotFoundException if the client is not found
   */
  public async refreshChartOfAccounts(
    partnerId: number,
    organizationId: number,
    ledgerId: number
  ): Promise<void> {
    // TODO: Can this partner access this specific organization?
    // TODO: Does this organization have a ledger connection?
    const clientController = new ClientController(this.db);
    const accountingController = new AccountingController(this.db);

    const ledgerConnection =
      await accountingController.getLedgerConnectionByClientId(
        partnerId
      );

    const propioLedgersMicroservice = new PropioLedgersMicroservice();

    await propioLedgersMicroservice.refreshChartOfAccounts(ledgerConnection);
  }

  public async getAccountingMappings(
    clientId: number
  ): Promise<BankAccountMappingResult> {
    const accountingController = new AccountingController(this.db);

    const bankAccounts = await accountingController.getBankAccountsForClient(
      clientId
    );
    logger.info(
      `Read bank accounts. This client has ${bankAccounts.length} bank accounts`
    );

    const chartOfAccounts =
      await accountingController.getChartOfAccountsForClient(clientId);
    logger.info(
      `Read chart of accounts. This client has ${chartOfAccounts.length} accounts`
    );

    const mappings = await accountingController.getBankAccountMappingsForClient(
      clientId
    );
    logger.info(
      `Read existing bank accounts mappings. This client has ${mappings.length} mappings`
    );

    return {
      bank_accounts: bankAccounts.map((bankAccount) => {
        const bankAccountModel: BankAccount = new Object() as BankAccount;
        bankAccountModel.plaid_account_id = bankAccount.account_id;
        bankAccountModel.name = bankAccount.name;
        return bankAccountModel;
      }),
      ledger_bank_accounts: chartOfAccounts,
      mappings: mappings.map((mapping: any) => {
        const bankAccountMappingModel: BankAccountMapping =
          new Object() as BankAccountMapping;

        bankAccountMappingModel.plaid_account_id = mapping?.plaid_account_id;
        bankAccountMappingModel.ledger_account_id = mapping?.ledger_account_id;

        return bankAccountMappingModel;
      }),
    };
  }

  public async saveMappings(
    body: BankAccountMapping[],
    clientId: number
  ): Promise<void> {
    logger.info(
      "Saving mappings for client " +
        clientId +
        " mappings: " +
        JSON.stringify(body)
    );
    const accountingController = new AccountingController(this.db);
    await accountingController.setBankAccountMappingsForClient(clientId, body);
  }

  /**
   * Categorize a transaction on the ledger.
   *
   * @param body a TransactionCategorizationRequest object. All object fields are required.
   *
   * @returns void Returns nothing if successful. Otherwise, throws an error.
   *
   * @throws BadRequestException if the ledger ID is not supported, or if the request is missing required fields.
   * @throws NotFoundException if the partner ID, transaction ID, or account ID cannot be found.
   * @throws ForbiddenException if the partner does not have access to the transaction.
   * @throws GenericException if the request fails for any other reason.
   */
  async categorizeTransactionOnLedger(
    body: TransactionCategorizationRequest
  ): Promise<void> {
    logger.info("Categorizing transaction on ledger");
    const auth0UserId = requireUserId(this.event);
    const partnerController = this.getPartnerController();
    const currentPartnerId = await partnerController.getPartnerIdByAuth0Id(
      auth0UserId
    );
    const transactionController = new TransactionsController(this.db);
    const ledgersMicroservice = new PropioLedgersMicroservice();
    const telemetryContext = new Map<string, string>();
    await transactionController.categorizeTransaction(
      body,
      currentPartnerId,
      ledgersMicroservice,
      telemetryContext
    );
    logger.info("Transaction categorized successfully");
  }

  /**
   * Get the chart of accounts for a given organization.
   *
   * @param partnerId The partner querying the chart of accounts
   * @param organizationId The target organization
   * @param ledgerId The ledger ID. 1 for QuickBooks, 2 for Xero, etc.
   * @returns An array of LegederAccount objects
   */
  public getLedgerChartOfAccounts = async (
    partnerId: number,
    organizationId: number,
    ledgerId: number
  ): Promise<LedgerAccount[]> => {
    // TODO: Can this partner access this specific organization?
    // TODO: Does this organization have a ledger connection?
    const transactionsController = new TransactionsController(this.db);
    return await transactionsController.getChartOfAccounts(organizationId);
  };

  public getClients = async (
    offset: number,
    limit: number
  ): Promise<Client[]> => {

    const clientController = new ClientController(this.db);
    const clientList = await clientController.getClients(
      limit,
      offset,
    );

    return clientList;
  };

  public getOrganizationClients = async (
    organizationId: number
  ): Promise<Client[]> => {
    const clientController = new ClientController(this.db);
    const clientList = await clientController.getClientsByOrganizationId(
      organizationId
    );
    return clientList;
  };

  public editClient = async (body: Client, clientId: number): Promise<void> => {
    const clientController = new ClientController(this.db);
    body.partner_uid = 23;
    body.client_uid = clientId;
    await clientController.editClient(body);
  };

  private getPartnerController(): PartnerController {
    return new PartnerController(this.db, "mail.com");
  }

  public createClient = async (body: Client): Promise<void> => {
    const clientController = new ClientController(this.db);
    await clientController.createClient(body);
  };

  public getFinancialInstitutionConnectionUrl = async (
    partnerId: number,
    organizationId: number
  ): Promise<BankLinkConnectionRequest> => {
    logger.info(
      `Generating a link for partner ${partnerId} and organization ${organizationId}`
    );
    return {
      plaid_link: 'NOT_IMPLEMENTED',
    };
  };

  public getLedgerConnectionUrl = async (
    partnerId: number,
    organizationId: number,
    ledgerId: number
  ): Promise<RedirectionUrl> => {
    return {
      url:'NOT_IMPLEMENTED', 
    };
  };

  public getLedgerDetails = async (
    partnerId: number,
    organizationId: number,
    ledgerId: number
  ): Promise<RedirectionUrl> => {
    return new Object() as RedirectionUrl;
  };

  public getOrganizationsForPartner = async (
    partnerId: number
  ): Promise<Organization[]> => {
    const controller = new OrganizationsController(this.db);
    const organizationList = await controller.getOrganizationsByPartnerId(
      partnerId
    );
    return organizationList;
  };

  public editOrganization = async (
    body: Organization,
    organizationId: number,
    partnerId: number
  ): Promise<void> => {
    const controller = new OrganizationsController(this.db);
    await controller.editOrganization(body, organizationId);
  };

  public getTransactionId = async (
    transactionId: number
  ): Promise<Transaction> => {
    return new Object() as Transaction;
  };

  public getTransactionsForClient = async (
    clientId: number,
    merchantQuery?: string,
    categorizationStatus?: string,
    dateStart?: string,
    dateEnd?: string
  ): Promise<Transaction[]> => {

    let service :     PropioAiCategorizationMicroservice = new PropioAiCategorizationMicroservice();
    let transactions = await service.requestSuggestion(1);
    return transactions;


    const controller = new TransactionsController(this.db);
    return await controller.getTransactions(clientId);

  };

  /**
   * Use AI to suggest a category for a transaction. This is an HTTP endpoint
   * so that the UI can also request suggestions, but the main flow is for
   * transactions to be automatically categorized by the AI as they come in.
   *
   * @param transactionId The transaction id
   */
  public suggestCategoryForTransaction = async (
    transactionId: number
  ): Promise<void> => {
    logger.info(
      `Requesting AI suggestion for transaction id : ${transactionId}`
    );

    // Make sure this transactions exists
    const controller = new TransactionsController(this.db);
    const transactionInDb = await controller.getTransaction(transactionId);
    if (!transactionInDb.plaid_transaction_id) {
      logger.error(`The transaction ${transactionId} does not exist`);
      throw new GenericException("No plaid_transaction_id");
    }

    // TODO: Check that the current partner/user has permission to categorize this transaction

    // Send the request to the AI categorization service
    await controller.requestSuggestion(transactionId);
  };

  /**
   * Check if a user exists in the service
   *
   * @param auth0Id The Auth0 ID of the user
   * @returns The user details
   */
  public getUserByAuth0Id = async (auth0Id: string): Promise<User> => {
    // This will throw if the user is not found:
    const userController = new UserController(this.db);
    return await userController.getUserByAuth0Id(auth0Id);
  };

  /**
   * Saves a new user in the service
   *
   * @param body The details of the user
   * @param auth0Id The Auth0 ID of the user
   * @returns The user details
   */
  public saveUser = async (body: User, auth0Id: string): Promise<void> => {
    // This will throw if the user is not found:
    const userController = new UserController(this.db);
    logger.info("Creating user " + auth0Id);

    await userController.saveUserByAuth0Id(auth0Id, body);
    logger.info("User saved successfully ");
  };

  public onboardUser = async (
    body: PartnerOnboardingRequest,
    auth0Id: string
  ): Promise<void> => {
    const partnerController = this.getPartnerController();

    await partnerController.onboardPartner(auth0Id, body);
  };

  public sendMessage = async (
    channelId: number,
    body: SendMessageRequest
  ): Promise<void> => {
    return;
  };

  /**
   * Change the category of a list of transactions.
   *
   * @param body An array of transactions to update
   */
  public updateTransactions = async (body: Transaction[]): Promise<void> => {
    logger.info(`updateTransactions(): Updating ${body.length} transactions.`);

    // Validate all inputs first, just making sure that the transaction category ID is present
    for (const transaction of body) {
      if (transaction.transaction_category_id === undefined) {
        throw new BadRequestException("Missing transaction category ID");
      }

      if (transaction.transaction_id === undefined) {
        throw new BadRequestException("Missing transaction ID");
      }
    }

    // Simply call the updateTransaction method for each transaction
    const promises = body.map((transaction) =>
      this.updateTransaction(transaction, transaction.transaction_id || 0)
    );

    // Wait for all promises to finish (succeed or fail)
    const results = await Promise.allSettled(promises);
    logger.info(`updateTransactions(): All promises finished.`);

    // If they all failed, throw an exception
    const allFailed = results.every((result) => result.status === "rejected");
    if (allFailed) {
      logger.info(`All transactions failed to processed`);
      throw new GenericException("All transactions failed to process");
    }

    // If they all succeeded, return
    const allSucceeded = results.every(
      (result) => result.status === "fulfilled"
    );
    if (allSucceeded) {
      logger.info(`All ${body.length} transactions processed`);
      return;
    }

    const failedResults = results.filter(
      (result) => result.status === "rejected"
    );

    for (const result of failedResults) {
      logger.error(`Transaction failed with reason:`);
      logger.error(JSON.stringify(result));
    }

    throw new GenericException("Some transactions failed to process");
  };

  /**
   * Update a transaction. The only field that you can update (for Plaid) ingested transactions
   * is the category. This will trigger a categorization request to the ledger.
   *
   * @param body The transaction to change.
   * @param transactionId The id of the transaction to change.
   */
  public updateTransaction = async (
    body: Transaction,
    transactionId: number
  ): Promise<void> => {
    logger.info(`updateTransaction(): Updating transaction ${transactionId}`);

    if (!body.transaction_category_id) {
      throw new BadRequestException("Missing transaction category ID");
    }

    const auth0UserId = requireUserId(this.event);
    const partnerController = this.getPartnerController();
    const currentPartnerId = await partnerController.getPartnerIdByAuth0Id(
      auth0UserId
    );

    const controller = new TransactionsController(this.db);
    const transactionInDb = await controller.getTransaction(transactionId);
    if (!transactionInDb.plaid_transaction_id) {
      throw new BadRequestException("No plaid_transaction_id");
    }

    try {
      const clientController = new ClientController(this.db);

      // Make sure there is a ledger connected to the client, otherwise
      // we won't be able to categorize the transaction.
      let ledger: ConenctedLedger;
      try {
        ledger = await clientController.getClientConnectedLedger(
          transactionInDb.client_id
        );
      } catch (e) {
        throw new BadRequestException("No ledger connected to client");
      }

      logger.info(
        `Creating request to categorize transaction: ${transactionId}`
      );

      const queueUrl = process.env.CATEGORIZE_TRANSACTION_QUEUE_URL;
      if (!queueUrl) {
        throw new GenericException("Missing queue URL");
      }

      const event: TransactionCategorizationMessage = {
        request: {
          transaction_id: transactionId,
          ledger_id: ledger.ledger_id,
          category_id: parseInt(body.transaction_category_id),
        },
        partner_id: currentPartnerId,
      };

      //
      // Put the message in the queue. ONLY for debugging purposes, change
      // useQueue to false to bypass the queue and categorize the transaction
      // directly.
      //
      // NOTE: NEVER LET THIS BE FALSE. False is just for development.
      const useQueue = true;
      // NOTE: NEVER LET THIS BE FALSE. False is just for development.
      if (useQueue) {
        logger.info("Adding message to queue", event);
        await this.queue.insert(queueUrl, null, event);
      } else {
        await new TransactionsController(this.db).categorizeTransaction(
          event.request,
          event.partner_id,
          new PropioLedgersMicroservice(),
          new Map<string, string>()
        );

        // Notify the success to the websocket service
        const notificationServiceContext = {
          transaction_id: transactionId.toString(),
        };

        const url = `https://api-v2-${process.env.ENVIRONMENT}.notifications.com/triggerWebsocketNotifications`;
        logger.info(
          `Notifying the notification service for transaction ${transactionId} : ${url}`
        );
        await fetch(url, {
          method: "POST",
          body: JSON.stringify(notificationServiceContext),
          headers: { "Content-Type": "application/json" },
        });
      }
    } catch (e) {
      logger.error("Failed to categorize transaction");
      logger.error(e);

      const notificationServiceContext: Map<string, string> = new Map();
      notificationServiceContext.set(
        "transaction_id",
        transactionId.toString()
      );
      notificationServiceContext.set("error", e.message);

      const url = `https://api-v2-${process.env.ENVIRONMENT}.notifications.com/triggerWebsocketNotifications`;
      await fetch(url, {
        method: "POST",
        body: JSON.stringify(notificationServiceContext),
        headers: {
          "Content-Type": "application/json",
        },
      });
      throw new GenericException("Error updating transaction");
    }
  };

  public createUser = async (body: User): Promise<void> => {
    //let { rows } = await this.db.execute("select * from user where id = ? ", [
    //  body.auth0_user_id,
    //]);
    //if (rows[0]) {
    //  // This means the user already exists
    //  return;
    //}
    //// Validate input. Required params are id, email, role
    //if (!body.id || !body.email || !body.role) {
    //  throw new BadRequestException();
    //}
    //let username = body.username;
    //const currentTime = dateutils.datetimeToDatabase(
    //  this.systemClock.getCurrentTime()
    //);
    //if (!body.name) {
    //  // If name is undefined, omit it from the insert query
    //  await this.db.execute(
    //    "insert into user (id, email, role, date_created, username) values (?, ?, ?, ?, ?)",
    //    [body.id, body.email, body.role, currentTime, username]
    //  );
    //} else {
    //  // If name is provided, include it in the insert query
    //  await this.db.execute(
    //    "insert into user (id, name, email, role, date_created, username) values (?, ?, ?, ?, ?, ?)",
    //    [body.id, body.name, body.email, body.role, currentTime, username]
    //  );
    //}
    //logger.info("Created user " + body.id);
    //// New users will receive welcome email
    //const email: Email = new Email();
    //await email.sendWelcomeEmailToUser(body.email);
    //// Now that the user has been created, see if this user has a pending invitation to join
    //// a project.
    //({ rows } = await this.db.execute(
    //  "select * from project_invitation where email = ? and active = 1 and invitation_link_consumed = 0;",
    //  [body.email]
    //));
    //for (const pendingInvitation of rows) {
    //  logger.info(
    //    "Resolving pending invitation for newly created user. Invitation id =  " +
    //      pendingInvitation.id
    //  );
    //  // There is a pending invitation for this user; now that the user exists, let's add
    //  // them to the corresponding project.
    //  await this.db.execute(
    //    "insert into project_user (project_id, user_id) values (?, ?)",
    //    [pendingInvitation.project_id, body.id]
    //  );
    //  // Now that we have a user ID, update the candidate table with the actual DevMatch user id
    //  await this.db.execute(
    //    "UPDATE `candidate` SET `devmatch_user_id` = ? WHERE (`email1` = ? and project_id = ? );",
    //    [body.id, body.email, pendingInvitation.project_id]
    //  );
    //  logger.info(
    //    `Added new user to pending project invitation. User=${body.id}, Project=${pendingInvitation.project_id}`
    //  );
    //  // Now, de-activate the invitation:
    //  await this.db.execute(
    //    "UPDATE `project_invitation` SET `invitation_link_consumed` = '1', `active` = 0 WHERE (`id` = ?);",
    //    [pendingInvitation.id]
    //  );
    //}
    //// Add user to hubspot
    //try {
    //  const hubspotContact: HubSpotService = new HubSpotService();
    //  await hubspotContact.createContact(body.email, {
    //    lifecyclestage: "lead",
    //  });
    //} catch (e) {
    //  // Don't actually fail the operation, just log it.
    //  logger.error("Unable to add to HubSpot; not fatal, just move on.");
    //  logger.error(e);
    //}
  };

  // ////////////////////////////////////////////////////////////////////////////
  // Methods that can be useful as reference
  // ////////////////////////////////////////////////////////////////////////////
  public getUsers = async (): Promise<any[]> => {
    const currentUserId = requireUserId(this.event);

    await requireGlobalAdmin(
      this.db,
      currentUserId,
      `User ${currentUserId} is not an admin and cannot get all users.`
    );

    const rows = await this.db.query("select * from user", []);
    for (const user of rows) {
      if (user.date_created) {
        user.date_created = dateutils.tozulufroms(user.date_created);
      }
    }

    return rows;
  };

  public getUser = async (id): Promise<any> => {
    const db = this.db;

    // You can request your own data, or the global admin
    const currentUserId = requireUserId(this.event);
    if (currentUserId !== id) {
      await requireGlobalAdmin(
        db,
        currentUserId,
        `User ${currentUserId} is not authorized to query user ${id}.`
      );
    }

    let rows = await db.query("select * from user where id = ? ", [id]);
    if (!rows[0]) {
      throw new NotFoundException();
    }

    const result: any = rows[0];
    if (result.date_created) {
      result.date_created = dateutils.tozulufroms(result.date_created);
    }

    // we would also like to know if there is an active project in which this
    // person needs to participate.
    const query =
      "select project.* from project, project_user where project_user.user_id = ? " +
      "and project.deleted = 0 and project.id = project_user.project_id and project.state = 'open';";
    rows = await db.query(query, [id]);
    rows.forEach((row) => {
      row.start_time = dateutils.tozulufroms(row.start_time);
      row.end_time = dateutils.tozulufroms(row.end_time);
    });

    result.projects = rows;

    // Return wether this user has logged in the past or not
    const loginQuery =
      "SELECT count(id) as count FROM login where user_id = ?;";
    rows = await db.query(loginQuery, [id]);
    result.hasLoggedIn = rows[0].count !== 0;

    // Does this user have a valid DevMatch license?
    result.license = await getLicenseForUser(
      result.email,
      id,
      db,
      this.systemClock
    );

    // if not, does anyone in an organization this user belongs to have a valid license?
    // TODO: this does NOT account for users that belong to multiple organizations.
    // If ANY user in ANY organization this user belongs to has a valid license,
    // this user will have a valid license
    if (!result.license.devmatch_valid_license) {
      rows = await db.query(
        `
        SELECT DISTINCT user_license.user_id, user_license.valid_license FROM user_organization
        LEFT JOIN user_license ON user_license.user_id = user_organization.user_id
        WHERE user_organization.organization_id IN
        (SELECT organization_id FROM user_organization WHERE user_id = ?)
        AND user_license.valid_license = 1
        `,
        [currentUserId]
      );

      if (rows.length > 0) {
        result.license = { devmatch_valid_license: true };
      }
    }

    return result;
  };

  public getUserPublic = async (username: string): Promise<any> => {
    const db = this.db;

    const { rows } = await db.execute(
      "select username, date_created, name, id from user where username = ? ",
      [username]
    );
    if (!rows[0]) {
      logger.warn(
        `Tried searching for user ${username}, but could not find it!!`
      );
      throw new NotFoundException();
    }

    logger.info(`Correctly got username=${username}`);
    const result: any = rows[0];
    if (result.date_created) {
      result.date_created = dateutils.tozulufroms(result.date_created);
    }

    return result;
  };

  public updateUser = async (body: User, id: string): Promise<void> => {
    const userid = id;

    const db = this.db;
    // Is the user updating their own data (or are they an admin)?
    const currentUserId = requireUserId(this.event);
    const isGlobalAdmin = await isUserGlobalAdmin(db, currentUserId);
    if (currentUserId !== userid && !isGlobalAdmin) {
      logger.warn(
        `User ${currentUserId} is not authorized to update user ${userid}.`
      );
      throw new ForbiddenException();
    }

    // Only update parameters that are given
    //let query = "update user set ";
    //const values: any[] = [];

    //if (body.name) {
    //  query = query.concat("name = ?,");
    //  values.push(body.name);
    //}

    //if (body.role && isGlobalAdmin) {
    //  query = query.concat("role = ?,");
    //  values.push(body.role);
    //}

    //if (body.email) {
    //  query = query.concat("email = ?,");
    //  values.push(body.email);
    //}

    //if (body.github) {
    //  query = query.concat("github = ?,");
    //  values.push(body.github);
    //}

    //if (body.username) {
    //  // is it this user's username?
    //  const { rows } = await db.execute(
    //    "SELECT * FROM user WHERE username = ? AND id = ?",
    //    [body.username, userid]
    //  );
    //  const usernameOwnedByThisUser = rows.length > 0;

    //  if (!usernameOwnedByThisUser) {
    //    // trying to change username. is the new one valid?
    //    const validUsername = await DevMatchUsernameGenerator.validUsername(
    //      body.username,
    //      db
    //    );

    //    if (!validUsername) {
    //      throw new BadRequestException("invalid username");
    //    }

    //    query = query.concat("username = ?,");
    //    values.push(body.username);
    //  }
    //}

    //// If no information is input, return invalid request
    //if (values.length === 0) {
    //  throw new BadRequestException();
    //}

    ////remove the last comma
    //query = query.substring(0, query.length - 1);

    //query = query.concat(" where id = ?");
    //values.push(userid);

    //await db.execute(query, values);
  };

  public createProject = async (body: any): Promise<any> => {
    // is the user setting themself as the owner?
    const currentUserId = requireUserId(this.event);

    if (!body.name) {
      const error = `must pass name`;
      throw new BadRequestException(error);
    }

    if (!body.description) {
      const error = `must pass description`;
      throw new BadRequestException(error);
    }

    if (!body.state) {
      const error = `must pass state`;
      throw new BadRequestException(error);
    }

    if (!(body.state === "open" || body.state === "closed")) {
      const error = `state must be open or closed`;
      throw new BadRequestException(error);
    }

    if (!body.start_time) {
      const error = `must pass a start time`;
      throw new BadRequestException(error);
    }

    if (!body.end_time) {
      const error = `must pass an end time`;
      throw new BadRequestException(error);
    }

    // if they are assigning this to an org, make sure they're part of that org
    if (body.organization_id !== undefined) {
      const canAssignToOrganization = await isUserInOrganization(
        this.db,
        currentUserId,
        body.organization_id
      );
      if (!canAssignToOrganization && body.organization_id !== null) {
        throw new ForbiddenException(
          "Current user may not assign a project to this organization"
        );
      }
    }

    const startDateTime = dateutils.datetimeToDatabase(
      new Date(body.start_time)
    );
    const endDateTime = dateutils.datetimeToDatabase(new Date(body.end_time));

    const db = this.db;
    const { lastInsertedId } = await db.execute(
      "insert into project (name, description, owner_id, state, start_time, end_time, organization_id) " +
        "values (?, ?, ?, ?, ?, ?, ?)",
      [
        body.name,
        body.description,
        currentUserId,
        body.state,
        startDateTime,
        endDateTime,
        body.organization_id ?? null,
      ]
    );

    await db.execute(
      "insert into project_user_admin (project_id, user_id) " + "values (?, ?)",
      [lastInsertedId, currentUserId]
    );

    // Return the newly inserted ID
    const result = new Object() as any;
    result.id = lastInsertedId;
    return result;
  };

  public deleteProject = async (projectId: number): Promise<void> => {
    // Read the id to update from the URL
    const currentUser = requireUserId(this.event);

    const rows = await this.db.query("SELECT * FROM project WHERE id = ?", [
      projectId,
    ]);
    if (rows.length === 0) {
      throw new NotFoundException();
    }

    // does the current user own this project?
    const isCurrentUserProjectAdmin = await isUserProjectAdmin(
      this.db,
      currentUser,
      projectId
    );
    if (!isCurrentUserProjectAdmin) {
      throw new ForbiddenException(
        `Current user is not authorized to delete project ${projectId}.`
      );
    }

    const query = "update project set deleted = 1 where id = ?";
    await this.db.execute(query, [projectId]);
    logger.info(`User ${currentUser} has deleted project ${projectId}`);
  };

  public updateProject = async (body: any, id: number): Promise<void> => {
    const projectid = id;

    // is the current user an admin on this project?
    const db = this.db;
    const currentUserId = requireUserId(this.event);

    const rows = await db.query("SELECT * FROM project WHERE id = ?", [
      projectid,
    ]);
    if (rows.length === 0) {
      throw new NotFoundException();
    }

    const isAdmin = await isUserProjectAdmin(db, currentUserId, projectid);
    if (!isAdmin) {
      const message = `User ${currentUserId} is not authorized to update project ${projectid}.`;
      logger.warn(message);
      throw new ForbiddenException(message);
    }

    // If configuration is specified, then parse the contents, and update
    // configurations. Override all previous configurations. And do validation.
    let updatedConfiguration = false;
    if (body.configuration) {
      // Parse the input
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      let newConfiguration: any[] = [];
      try {
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        newConfiguration = body.configuration
          .filter((el) => el.name && el.value)
          .map((el) => {
            const config = new Object();
            return config;
          });
        updatedConfiguration = true;
      } catch (e) {
        throw new BadRequestException("Unable to parse configuration");
      }

      // Now save it
      //const projectController = new ProjectsController(db, this.systemClock);
      //await projectController.saveProjectConfiguration(
      //  projectid,
      //  newConfiguration
      //);
    }

    // Only update parameters that are given
    let query = "update project set ";
    const values: any[] = [];
    if (body.name) {
      query = query.concat("name = ?,");
      values.push(body.name);
    }

    if (body.description) {
      query = query.concat("description = ?,");
      values.push(body.description);
    }

    if (body.state) {
      query = query.concat("state = ?,");
      values.push(body.state);
    }

    if (body.start_time) {
      query = query.concat("start_time = ?,");
      values.push(
        dateutils.datetimeToDatabase(new Date(Date.parse(body.start_time)))
      );
    }

    if (body.end_time) {
      query = query.concat("end_time = ?,");
      values.push(
        dateutils.datetimeToDatabase(new Date(Date.parse(body.end_time)))
      );
    }

    // if they are assigning this to an org, make sure they're part of that org
    if (body.organization_id !== undefined) {
      const canAssignToOrganization = await isUserInOrganization(
        this.db,
        currentUserId,
        body.organization_id
      );
      if (!canAssignToOrganization && body.organization_id !== null) {
        throw new ForbiddenException(
          "Current user may not assign a project to this organization"
        );
      }

      // request may want to set org id to null, so we always run this update
      query = query.concat("organization_id = ?,");
      values.push(body.organization_id ?? null);
    }

    // If no information is input, return invalid request
    if (!updatedConfiguration && values.length === 0) {
      throw new BadRequestException("Nothing to update.");
    }

    if (values.length > 0) {
      // Remove the last comma
      query = query.substring(0, query.length - 1);

      query = query.concat(" where id = ?");
      values.push(projectid);

      await db.execute(query, values);
    }
  };

  public createTransactionForOrganization = async (
    partnerId: number,
    organizationId: number,
    body: Transaction
  ): Promise<void> => {
    const clientController = new ClientController(this.db);
    //const client =
    //  await clientController.getSingleClientByOrganizationIdAndPartnerId(
    //    organizationId,
    //    partnerId
    //  );
    const transactionController = new TransactionsController(this.db);
    await transactionController.createTransaction(
      body,
      partnerId,
      partnerId
    );
  };

  public async shareClientsforPartners(body: ShareClientParams): Promise<void> {
    logger.info(`Sharing clients with partners API called`);

    if (body.sharedClientIds.length == 0 || body.targetPartnerIds.length == 0) {
      throw new BadRequestException("Invalid request");
    }

    const values: string[] = [];
    const parameters: number[] = [];
    let parameterIndex = 1;

    body.targetPartnerIds.forEach((partnerId) => {
      body.sharedClientIds.forEach((clientId) => {
        logger.info(`Sharing client ${clientId} with partner ${partnerId}`);
        values.push(`($${parameterIndex}, $${parameterIndex + 1})`);
        parameters.push(partnerId, clientId);
        parameterIndex += 2;
      });
    });

    const query = `
        INSERT INTO propio_partner_client_map
            (partner_id, client_id)
        VALUES
            ${values.join(", ")}
        ON CONFLICT (partner_id, client_id)
        DO NOTHING
        `;

    try {
      await this.db.execute(query, parameters);
      console.log("Clients shared successfully");
    } catch (error) {
      logger.error("Database error:", error);
      throw new Error("Failed to share clients with partners");
    }

    const telemetryContext = new Map<string, string>();
    telemetryContext["partner_ids"] = body.targetPartnerIds.join(",");
    telemetryContext["client_ids"] = body.sharedClientIds.join(",");

  }

  public getPartnersFromEmails(body: string[]): Promise<Partner[]> {
    const partnerController = this.getPartnerController();
    return partnerController.findPartnersByEmails(body);
  }
}
